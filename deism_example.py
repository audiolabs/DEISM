""" 
An example of using DEISM, DEISM-LC and comparison with FEM simulation
The DEISM and DEISM-LC use precalculated directivities of the source and receiver,
which are simulated using FEM tools (COMSOL in our case) in free-field.
The directivities include local scattering and diffraction effect around the source and receiver.
You can use your own directivity data, as long as they are processed correctly.
Then DEISM and DEISM-LC calculates the sound field generated by the source,
captured by the receiver.
Since the spherical harmonic domain computation is quite expensive,
we utilize the ray() package to allow parallel computation.
The SPL and phase of the computed sound fields are then visualized along with
the solutions from FEM (as groud truth) 
"""

# -------------------------------------------------------
# Authors: Zeyu Xu and Emanuel Habets
# Email: zeyu.xu@audiolabs-erlangen.de
# -------------------------------------------------------

import numpy as np
import matplotlib.pyplot as plt
import ray
import psutil
from helper import (
    get_C_nm_s,
    get_C_vu_r,
    pre_calc_Wigner,
    pre_calc_images_src_rec,
    ray_run_DEISM,
    ray_run_DEISM_LC,
    load_segdata_room,
)


def initialize_params():
    """Initialize parameters related to the simulation."""
    params = {
        "c": 343,  # speed of sound
        "LL": np.array([4, 3, 2.5]),  # Room size
        "N_o": 20,  # Maximum reflection order
        "fs": 2000,  # Sampling rate
        "RT60": 0.3,
        "fstart": 20,  # start frequency
        "fstep": 2,  # frequency step size
        "fstop": 1000,  # stop frequency
        "Z_S": 18,  # The acoustic impedance of the walls
        "beta_RefCoef": list(np.ones(6) * 17 / 19),
        "RefCoef_angdep_flag": 1,
        "Q": 0.001,  # Point source flow strength used in FEM simulation
        "rho0": 1.2,  # constant of air
        "src_rec_type": "speaker_cuboid_cyldriver",
        "num_samples": 1764,  # Number of sample points on the transparent sphere
        "sampling_scheme": "uniform",
        "x_s": np.array([1.1, 1.1, 1.3]),  # source position
        "N_src_dir": 5,  # max. spherical harmonic directivity order
        "r0_src": np.array([0.4]),  # Radius of transparent sphere
        "x_r": np.array([2.9, 1.9, 1.3]),  # receiver position
        "V_rec_dir": 5,  # max. spherical harmonic directivity order
        "r0_rec": np.array([0.5]),  # Radius of transparent sphere
    }

    params["nSamples"] = int(params["fs"] * params["RT60"])
    params["freqs"] = np.arange(
        params["fstart"], params["fstop"] + params["fstep"], params["fstep"])
    params["k"] = 2 * np.pi * params["freqs"] / params["c"]  # wavenumbers
    params["S"] = 1j * params["k"] * params["c"] * params["rho0"] * \
        params["Q"]  # point source strength compensation

    cTs = params["c"] / params["fs"]
    L = params["LL"] / cTs
    params["n1"], params["n2"], params["n3"] = (
        np.ceil(params["nSamples"] / (2 * L)).astype(int))

    return params


def load_directivity_data(params, src_facing, rec_facing):
    """Load directivity data for both source and receiver."""
    params["C_nm_s"] = get_C_nm_s(params, src_facing)[0]
    params["C_vu_r"] = get_C_vu_r(params, rec_facing)[0]


def plot_results(freqs, P_DEISM, P_DEISM_LC, RTF_COMSOL, PLOT_SCALE="dB", IF_UNWRAP_PHASE=1, IF_SAME_MAGSCALE=1):
    """Plot the results of the simulations."""

    # Set up latex for plotting
    plt.rcParams["text.usetex"] = True

    # Initialize the SPL arrays
    plot_mag_DEISM = np.zeros_like(P_DEISM, dtype="float")
    plot_mag_DEISM_LC = np.zeros_like(P_DEISM, dtype="float")
    plot_mag_COMSOL = np.zeros_like(P_DEISM, dtype="float")

    # dB or linear scale
    P0 = 20 * 10 ** (-6)  # reference pressure
    if PLOT_SCALE == "linear":
        plot_mag_DEISM = np.abs(P_DEISM)
        plot_mag_DEISM_LC = np.abs(P_DEISM_LC)
        plot_mag_COMSOL = np.abs(RTF_COMSOL)
    elif PLOT_SCALE == "dB":
        p_rms_DEISM = np.abs(np.sqrt(0.5 * P_DEISM * P_DEISM.conjugate()))
        p_rms_DEISM_LC = np.abs(
            np.sqrt(0.5 * P_DEISM_LC * P_DEISM_LC.conjugate()))
        p_rms_COMSOL = np.abs(
            np.sqrt(0.5 * RTF_COMSOL * RTF_COMSOL.conjugate()))
        plot_mag_DEISM = 20 * np.log10(p_rms_DEISM / P0)
        plot_mag_DEISM_LC = 20 * np.log10(p_rms_DEISM_LC / P0)
        plot_mag_COMSOL = 20 * np.log10(p_rms_COMSOL / P0)

    # Plot magnitudes of the room transfer functions
    fig = plt.figure(figsize=(18, 8))
    ax = fig.add_subplot(1, 1, 1)
    ax.plot(freqs, plot_mag_DEISM, label="DEISM",
            color="lightgray", linewidth=3)
    ax.plot(
        freqs,
        plot_mag_DEISM_LC,
        label="DEISM LC",
        linestyle="dotted",
        color="gray",
        linewidth=3,
    )
    ax.plot(freqs, plot_mag_COMSOL, label="FEM", color="black", linewidth=3)
    ax.set_xlim([freqs[0], freqs[-1]])
    ax.set_xlabel(r"\bf{Frequency (Hz)}")
    if IF_SAME_MAGSCALE == 1:
        ax.set_ylim([-10, 60])
    if PLOT_SCALE == "linear":
        ax.set_ylabel(r"\bf{Magnitude}")
    elif PLOT_SCALE == "dB":
        ax.set_ylabel(r"\bf{Magnitude (dB)}")
    ax.xaxis.label.set_size(25)
    ax.yaxis.label.set_size(25)
    ax.xaxis.set_tick_params(labelsize=25)
    ax.yaxis.set_tick_params(labelsize=25)
    # ax.set_title('Magnitude of Transfer Functions')
    ax.legend(fontsize=20)
    plt.grid(axis="both", linestyle=":")
    fig.tight_layout()
    plt.show()

    # Plot phases of the room transfer functions
    fig = plt.figure(figsize=(18, 8))
    ax = fig.add_subplot(1, 1, 1)
    if IF_UNWRAP_PHASE == 1:  # Unwarp the phase plots
        ax.plot(
            freqs,
            np.unwrap(np.angle(P_DEISM)) / np.pi,
            label="DEISM",
            color="lightgray",
            linewidth=3,
        )
        ax.plot(
            freqs,
            np.unwrap(np.angle(P_DEISM_LC)) / np.pi,
            label="DEISM LC",
            linestyle="dotted",
            color="gray",
            linewidth=3,
        )
        ax.plot(
            freqs,
            np.unwrap(np.angle(RTF_COMSOL)) / np.pi,
            label="FEM",
            color="black",
            linewidth=3,
        )
    else:
        ax.plot(
            freqs,
            np.angle(P_DEISM) / np.pi,
            label="DEISM",
            color="lightgray",
            linewidth=3,
        )
        ax.plot(
            freqs,
            np.angle(P_DEISM_LC) / np.pi,
            label="DEISM LC",
            linestyle="dotted",
            color="gray",
            linewidth=3,
        )
        ax.plot(
            freqs,
            np.angle(RTF_COMSOL) / np.pi,
            label="FEM",
            color="black",
            linewidth=3,
        )
    ax.set_xlim([freqs[0], freqs[-1]])
    ax.set_xlabel(r"\bf{Frequency (Hz)}")
    ax.set_ylabel(r"\bf{Phase} ($\pi$)")
    # ax.set_title('Phase of Transfer Functions')
    ax.xaxis.label.set_size(25)
    ax.yaxis.label.set_size(25)
    ax.xaxis.set_tick_params(labelsize=25)
    ax.yaxis.set_tick_params(labelsize=25)
    ax.legend(fontsize=20)
    plt.grid(axis="both", linestyle=":")
    fig.tight_layout()
    plt.show()


def main():
    params = initialize_params()

    src_facing = np.array([0, 0, 0])
    rec_facing = np.array([180, 0, 0])
    load_directivity_data(params, src_facing, rec_facing)

    # Precompute Wigner function
    Wigner = pre_calc_Wigner(params)

    # Precompute reflection paths
    images = pre_calc_images_src_rec(params)

    # Initialize Ray
    num_cpus = psutil.cpu_count(logical=False)
    if not ray.is_initialized():
        ray.init(num_cpus=num_cpus)

    # Simulate room impulse responses
    P_DEISM = ray_run_DEISM(params, images, Wigner)
    P_DEISM_LC = ray_run_DEISM_LC(params, images)

    # Shutdown Ray
    ray.shutdown()

    # Load COMSOL simulation result for comparison
    freqs, RTF_COMSOL = load_segdata_room("two_speaker_cuboid_cyldriver_pos_1")
    RTF_COMSOL = RTF_COMSOL[:, 0]

    plot_results(freqs, P_DEISM, P_DEISM_LC, RTF_COMSOL)


if __name__ == "__main__":
    main()
